# Generated by Haxe 3.4.7
# coding: utf-8

import math as python_lib_Math
import math as Math
import functools as python_lib_Functools
import inspect as python_lib_Inspect
import random as python_lib_Random
from io import StringIO as python_lib_io_StringIO


class _hx_AnonObject:
    def __init__(self, fields):
        self.__dict__ = fields


class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            _this = self.params
            return (((HxOverrides.stringOrNull(self.tag) + "(") + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _this]))) + ")")



class EnumValue:
    _hx_class_name = "EnumValue"


class List:
    _hx_class_name = "List"
    __slots__ = ("h", "q", "length")
    _hx_fields = ["h", "q", "length"]
    _hx_methods = ["push", "remove", "iterator"]

    def __init__(self):
        self.q = None
        self.h = None
        self.length = 0

    def push(self,item):
        x = _List_ListNode(item,self.h)
        self.h = x
        if (self.q is None):
            self.q = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1

    def remove(self,v):
        prev = None
        l = self.h
        while (l is not None):
            if (l.item == v):
                if (prev is None):
                    self.h = l.next
                else:
                    prev.next = l.next
                if (self.q == l):
                    self.q = prev
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.length
                _hx_local_0.length = (_hx_local_1 - 1)
                _hx_local_1
                return True
            prev = l
            l = l.next
        return False

    def iterator(self):
        return _List_ListIterator(self.h)



class _List_ListNode:
    _hx_class_name = "_List.ListNode"
    __slots__ = ("item", "next")
    _hx_fields = ["item", "next"]

    def __init__(self,item,next):
        self.item = item
        self.next = next



class _List_ListIterator:
    _hx_class_name = "_List.ListIterator"
    __slots__ = ("head",)
    _hx_fields = ["head"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,head):
        self.head = head

    def hasNext(self):
        return (self.head is not None)

    def next(self):
        val = self.head.item
        self.head = self.head.next
        return val



class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["string"]

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")


class StringBuf:
    _hx_class_name = "StringBuf"
    __slots__ = ("b",)
    _hx_fields = ["b"]

    def __init__(self):
        self.b = python_lib_io_StringIO()



class byte__ByteData_ByteData_Impl_:
    _hx_class_name = "byte._ByteData.ByteData_Impl_"
    __slots__ = ()
    _hx_statics = ["get_length", "readByte", "_new", "ofString", "readString"]
    length = None

    @staticmethod
    def get_length(this1):
        return this1.length

    @staticmethod
    def readByte(this1,i):
        return this1.b[i]

    @staticmethod
    def _new(data):
        this1 = data
        return this1

    @staticmethod
    def ofString(s):
        this1 = haxe_io_Bytes.ofString(s)
        return this1

    @staticmethod
    def readString(this1,pos,_hx_len):
        return this1.getString(pos,_hx_len)


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    __slots__ = ()


class haxe_ds_GenericCell:
    _hx_class_name = "haxe.ds.GenericCell"
    __slots__ = ("elt", "next")
    _hx_fields = ["elt", "next"]

    def __init__(self,elt,next):
        self.elt = elt
        self.next = next



class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]

    def __init__(self):
        self.h = dict()



class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["getString", "toString"]
    _hx_statics = ["ofString"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def getString(self,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

    def toString(self):
        return self.getString(0,self.length)

    @staticmethod
    def ofString(s):
        b = bytearray(s,"UTF-8")
        return haxe_io_Bytes(len(b),b)



class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        return "Eof"


class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, [e])
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, list())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, list())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, list())

class haxe_macro_Constant(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.Constant"

    @staticmethod
    def CInt(v):
        return haxe_macro_Constant("CInt", 0, [v])

    @staticmethod
    def CFloat(f):
        return haxe_macro_Constant("CFloat", 1, [f])

    @staticmethod
    def CString(s):
        return haxe_macro_Constant("CString", 2, [s])

    @staticmethod
    def CIdent(s):
        return haxe_macro_Constant("CIdent", 3, [s])

    @staticmethod
    def CRegexp(r,opt):
        return haxe_macro_Constant("CRegexp", 4, [r,opt])


class hxparse_LexEngine:
    _hx_class_name = "hxparse.LexEngine"
    __slots__ = ("uid", "nodes", "finals", "states", "hstates")
    _hx_fields = ["uid", "nodes", "finals", "states", "hstates"]
    _hx_methods = ["firstState", "makeState", "getTransitions", "addNode", "addNodes", "node", "initNode"]
    _hx_statics = ["MAX_CODE", "EMPTY", "ALL_CHARS", "single", "parse", "next", "plus", "star", "opt", "cinter", "cdiff", "ccomplement", "cunion", "parseInner"]

    def __init__(self,patterns):
        self.nodes = []
        self.finals = []
        self.states = []
        self.hstates = haxe_ds_StringMap()
        self.uid = 0
        pid = 0
        _g = 0
        while (_g < len(patterns)):
            p = (patterns[_g] if _g >= 0 and _g < len(patterns) else None)
            _g = (_g + 1)
            id = pid
            pid = (pid + 1)
            def _hx_local_3():
                _hx_local_1 = self
                _hx_local_2 = _hx_local_1.uid
                _hx_local_1.uid = (_hx_local_2 + 1)
                return _hx_local_2
            f = hxparse__LexEngine_Node(_hx_local_3(),id)
            n = self.initNode(p,f,id)
            _this = self.nodes
            _this.append(n)
            _this1 = self.finals
            _this1.append(f)
        self.makeState(self.addNodes([],self.nodes))

    def firstState(self):
        return (self.states[0] if 0 < len(self.states) else None)

    def makeState(self,nodes):
        _gthis = self
        buf_b = python_lib_io_StringIO()
        _g = 0
        while (_g < len(nodes)):
            n = (nodes[_g] if _g >= 0 and _g < len(nodes) else None)
            _g = (_g + 1)
            buf_b.write(Std.string(n.id))
            buf_b.write("".join(map(chr,[45])))
        key = buf_b.getvalue()
        s = self.hstates.h.get(key,None)
        if (s is not None):
            return s
        s = hxparse_State()
        _this = self.states
        _this.append(s)
        self.hstates.h[key] = s
        trans = self.getTransitions(nodes)
        _g1 = 0
        while (_g1 < len(trans)):
            t = (trans[_g1] if _g1 >= 0 and _g1 < len(trans) else None)
            _g1 = (_g1 + 1)
            target = self.makeState(t.n)
            _g11 = 0
            _g2 = t.chars
            while (_g11 < len(_g2)):
                _hx_chr = (_g2[_g11] if _g11 >= 0 and _g11 < len(_g2) else None)
                _g11 = (_g11 + 1)
                _g4 = _hx_chr.min
                _g3 = (_hx_chr.max + 1)
                while (_g4 < _g3):
                    i = _g4
                    _g4 = (_g4 + 1)
                    s.trans[i] = target
        def _hx_local_5():
            _g5 = 0
            _g12 = _gthis.finals
            while (_g5 < len(_g12)):
                f = (_g12[_g5] if _g5 >= 0 and _g5 < len(_g12) else None)
                _g5 = (_g5 + 1)
                _g21 = 0
                while (_g21 < len(nodes)):
                    n1 = (nodes[_g21] if _g21 >= 0 and _g21 < len(nodes) else None)
                    _g21 = (_g21 + 1)
                    if (n1 == f):
                        s.final = n1.pid
                        return
        setFinal = _hx_local_5
        if (s.final == -1):
            setFinal()
        return s

    def getTransitions(self,nodes):
        tl = []
        _g = 0
        while (_g < len(nodes)):
            n = (nodes[_g] if _g >= 0 and _g < len(nodes) else None)
            _g = (_g + 1)
            _g1 = 0
            _g2 = n.trans
            while (_g1 < len(_g2)):
                t = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                tl.append(t)
        def _hx_local_2(t1,t2):
            return (t1.n.id - t2.n.id)
        tl.sort(key= python_lib_Functools.cmp_to_key(_hx_local_2))
        t0 = (tl[0] if 0 < len(tl) else None)
        _g11 = 1
        _g3 = len(tl)
        while (_g11 < _g3):
            i = _g11
            _g11 = (_g11 + 1)
            t11 = (tl[i] if i >= 0 and i < len(tl) else None)
            if (t0.n == t11.n):
                python_internal_ArrayImpl._set(tl, (i - 1), None)
                t11 = _hx_AnonObject({'chars': hxparse_LexEngine.cunion(t0.chars,t11.chars), 'n': t11.n})
                python_internal_ArrayImpl._set(tl, i, t11)
            t0 = t11
        while python_internal_ArrayImpl.remove(tl,None):
            pass
        allChars = hxparse_LexEngine.EMPTY
        allStates = List()
        _g4 = 0
        while (_g4 < len(tl)):
            t3 = (tl[_g4] if _g4 >= 0 and _g4 < len(tl) else None)
            _g4 = (_g4 + 1)
            states = List()
            states.push(_hx_AnonObject({'chars': hxparse_LexEngine.cdiff(t3.chars,allChars), 'n': [t3.n]}))
            _g1_head = allStates.h
            while (_g1_head is not None):
                val = _g1_head.item
                _g1_head = _g1_head.next
                s = val
                nodes1 = list(s.n)
                x = t3.n
                nodes1.append(x)
                states.push(_hx_AnonObject({'chars': hxparse_LexEngine.cinter(s.chars,t3.chars), 'n': nodes1}))
                states.push(_hx_AnonObject({'chars': hxparse_LexEngine.cdiff(s.chars,t3.chars), 'n': s.n}))
            _g1_head1 = states.h
            while (_g1_head1 is not None):
                val1 = _g1_head1.item
                _g1_head1 = _g1_head1.next
                s1 = val1
                if (len(s1.chars) == 0):
                    states.remove(s1)
            allChars = hxparse_LexEngine.cunion(allChars,t3.chars)
            allStates = states
        states1 = []
        _g_head = allStates.h
        while (_g_head is not None):
            val2 = _g_head.item
            _g_head = _g_head.next
            s2 = val2
            x1 = _hx_AnonObject({'chars': s2.chars, 'n': self.addNodes([],s2.n)})
            states1.append(x1)
        def _hx_local_4(s11,s21):
            a = len(s11.chars)
            b = len(s21.chars)
            _g12 = 0
            _g5 = (a if ((a < b)) else b)
            while (_g12 < _g5):
                i1 = _g12
                _g12 = (_g12 + 1)
                a1 = (s11.chars[i1] if i1 >= 0 and i1 < len(s11.chars) else None)
                b1 = (s21.chars[i1] if i1 >= 0 and i1 < len(s21.chars) else None)
                if (a1.min != b1.min):
                    return (b1.min - a1.min)
                if (a1.max != b1.max):
                    return (b1.max - a1.max)
            if (a < b):
                return (b - a)
            return 0
        states1.sort(key= python_lib_Functools.cmp_to_key(_hx_local_4))
        return states1

    def addNode(self,nodes,n):
        _g = 0
        while (_g < len(nodes)):
            n2 = (nodes[_g] if _g >= 0 and _g < len(nodes) else None)
            _g = (_g + 1)
            if (n == n2):
                return
        nodes.append(n)
        self.addNodes(nodes,n.epsilon)

    def addNodes(self,nodes,add):
        _g = 0
        while (_g < len(add)):
            n = (add[_g] if _g >= 0 and _g < len(add) else None)
            _g = (_g + 1)
            self.addNode(nodes,n)
        return nodes

    def node(self,pid):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.uid
                _hx_local_0.uid = (_hx_local_1 + 1)
                return _hx_local_1
            return hxparse__LexEngine_Node(_hx_local_2(),pid)
        return _hx_local_3()

    def initNode(self,p,final,pid):
        p1 = p.index
        if (p1 == 0):
            return final
        elif (p1 == 1):
            c = p.params[0]
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.uid
                _hx_local_0.uid = (_hx_local_1 + 1)
                return _hx_local_1
            n = hxparse__LexEngine_Node(_hx_local_2(),pid)
            _this = n.trans
            _this.append(_hx_AnonObject({'chars': c, 'n': final}))
            return n
        elif (p1 == 2):
            p2 = p.params[0]
            def _hx_local_5():
                _hx_local_3 = self
                _hx_local_4 = _hx_local_3.uid
                _hx_local_3.uid = (_hx_local_4 + 1)
                return _hx_local_4
            n1 = hxparse__LexEngine_Node(_hx_local_5(),pid)
            an = self.initNode(p2,n1,pid)
            _this1 = n1.epsilon
            _this1.append(an)
            _this2 = n1.epsilon
            _this2.append(final)
            return n1
        elif (p1 == 3):
            p3 = p.params[0]
            def _hx_local_8():
                _hx_local_6 = self
                _hx_local_7 = _hx_local_6.uid
                _hx_local_6.uid = (_hx_local_7 + 1)
                return _hx_local_7
            n2 = hxparse__LexEngine_Node(_hx_local_8(),pid)
            an1 = self.initNode(p3,n2,pid)
            _this3 = n2.epsilon
            _this3.append(an1)
            _this4 = n2.epsilon
            _this4.append(final)
            return an1
        elif (p1 == 4):
            b = p.params[1]
            a = p.params[0]
            return self.initNode(a,self.initNode(b,final,pid),pid)
        elif (p1 == 5):
            b1 = p.params[1]
            a1 = p.params[0]
            def _hx_local_11():
                _hx_local_9 = self
                _hx_local_10 = _hx_local_9.uid
                _hx_local_9.uid = (_hx_local_10 + 1)
                return _hx_local_10
            n3 = hxparse__LexEngine_Node(_hx_local_11(),pid)
            _this5 = n3.epsilon
            x = self.initNode(a1,final,pid)
            _this5.append(x)
            _this6 = n3.epsilon
            x1 = self.initNode(b1,final,pid)
            _this6.append(x1)
            return n3
        elif (p1 == 6):
            p4 = p.params[0]
            return self.initNode(p4,final,pid)
        else:
            pass

    @staticmethod
    def single(c):
        return [_hx_AnonObject({'min': c, 'max': c})]

    @staticmethod
    def parse(pattern):
        this1 = haxe_io_Bytes.ofString(pattern)
        p = hxparse_LexEngine.parseInner(this1)
        if (p is None):
            raise _HxException((("Invalid pattern '" + ("null" if pattern is None else pattern)) + "'"))
        return p.pattern

    @staticmethod
    def next(a,b):
        if (a == hxparse__LexEngine_Pattern.Empty):
            return b
        else:
            return hxparse__LexEngine_Pattern.Next(a,b)

    @staticmethod
    def plus(r):
        if (r.index == 4):
            r2 = r.params[1]
            r1 = r.params[0]
            return hxparse__LexEngine_Pattern.Next(r1,hxparse_LexEngine.plus(r2))
        else:
            return hxparse__LexEngine_Pattern.Plus(r)

    @staticmethod
    def star(r):
        if (r.index == 4):
            r2 = r.params[1]
            r1 = r.params[0]
            return hxparse__LexEngine_Pattern.Next(r1,hxparse_LexEngine.star(r2))
        else:
            return hxparse__LexEngine_Pattern.Star(r)

    @staticmethod
    def opt(r):
        if (r.index == 4):
            r2 = r.params[1]
            r1 = r.params[0]
            return hxparse__LexEngine_Pattern.Next(r1,hxparse_LexEngine.opt(r2))
        else:
            return hxparse__LexEngine_Pattern.Choice(r,hxparse__LexEngine_Pattern.Empty)

    @staticmethod
    def cinter(c1,c2):
        return hxparse_LexEngine.ccomplement(hxparse_LexEngine.cunion(hxparse_LexEngine.ccomplement(c1),hxparse_LexEngine.ccomplement(c2)))

    @staticmethod
    def cdiff(c1,c2):
        return hxparse_LexEngine.ccomplement(hxparse_LexEngine.cunion(hxparse_LexEngine.ccomplement(c1),c2))

    @staticmethod
    def ccomplement(c):
        first = (c[0] if 0 < len(c) else None)
        start = ((((None if ((len(c) == 0)) else c.pop(0))).max + 1) if (((first is not None) and ((first.min == -1)))) else -1)
        out = []
        _g = 0
        while (_g < len(c)):
            k = (c[_g] if _g >= 0 and _g < len(c) else None)
            _g = (_g + 1)
            x = _hx_AnonObject({'min': start, 'max': (k.min - 1)})
            out.append(x)
            start = (k.max + 1)
        if (start <= 255):
            out.append(_hx_AnonObject({'min': start, 'max': 255}))
        return out

    @staticmethod
    def cunion(ca,cb):
        i = 0
        j = 0
        out = []
        a = i
        i = (i + 1)
        a1 = (ca[a] if a >= 0 and a < len(ca) else None)
        b = j
        j = (j + 1)
        b1 = (cb[b] if b >= 0 and b < len(cb) else None)
        while True:
            if (a1 is None):
                out.append(b1)
                while (j < len(cb)):
                    x = j
                    j = (j + 1)
                    x1 = (cb[x] if x >= 0 and x < len(cb) else None)
                    out.append(x1)
                break
            if (b1 is None):
                out.append(a1)
                while (i < len(ca)):
                    x2 = i
                    i = (i + 1)
                    x3 = (ca[x2] if x2 >= 0 and x2 < len(ca) else None)
                    out.append(x3)
                break
            if (a1.min <= b1.min):
                if ((a1.max + 1) < b1.min):
                    out.append(a1)
                    a2 = i
                    i = (i + 1)
                    a1 = (ca[a2] if a2 >= 0 and a2 < len(ca) else None)
                elif (a1.max < b1.max):
                    b1 = _hx_AnonObject({'min': a1.min, 'max': b1.max})
                    a3 = i
                    i = (i + 1)
                    a1 = (ca[a3] if a3 >= 0 and a3 < len(ca) else None)
                else:
                    b2 = j
                    j = (j + 1)
                    b1 = (cb[b2] if b2 >= 0 and b2 < len(cb) else None)
            else:
                tmp = ca
                ca = cb
                cb = tmp
                tmp1 = j
                j = i
                i = tmp1
                tmp2 = a1
                a1 = b1
                b1 = tmp2
        return out

    @staticmethod
    def parseInner(pattern,i = 0,pDepth = 0):
        if (i is None):
            i = 0
        if (pDepth is None):
            pDepth = 0
        r = hxparse__LexEngine_Pattern.Empty
        l = pattern.length
        while (i < l):
            i1 = i
            i = (i + 1)
            c = pattern.b[i1]
            if (c > 255):
                raise _HxException(c)
            c1 = c
            if (c1 == 40):
                r2 = hxparse_LexEngine.parseInner(pattern,i,(pDepth + 1))
                i = r2.pos
                r = hxparse_LexEngine.next(r,r2.pattern)
            elif (c1 == 41):
                if (r == hxparse__LexEngine_Pattern.Empty):
                    raise _HxException("Empty group")
                return _hx_AnonObject({'pattern': hxparse__LexEngine_Pattern.Group(r), 'pos': i})
            elif (c1 == 42):
                if (r != hxparse__LexEngine_Pattern.Empty):
                    r = hxparse_LexEngine.star(r)
                else:
                    r = hxparse_LexEngine.next(r,hxparse__LexEngine_Pattern.Match([_hx_AnonObject({'min': c, 'max': c})]))
            elif (c1 == 43):
                if (r != hxparse__LexEngine_Pattern.Empty):
                    r = hxparse_LexEngine.plus(r)
                else:
                    r = hxparse_LexEngine.next(r,hxparse__LexEngine_Pattern.Match([_hx_AnonObject({'min': c, 'max': c})]))
            elif (c1 == 46):
                r = hxparse_LexEngine.next(r,hxparse__LexEngine_Pattern.Match(hxparse_LexEngine.ALL_CHARS))
            elif (c1 == 63):
                if (r != hxparse__LexEngine_Pattern.Empty):
                    r = hxparse_LexEngine.opt(r)
                else:
                    r = hxparse_LexEngine.next(r,hxparse__LexEngine_Pattern.Match([_hx_AnonObject({'min': c, 'max': c})]))
            elif (c1 == 91):
                if (pattern.length > 1):
                    range = 0
                    acc = []
                    _hx_not = (pattern.b[i] == 94)
                    if _hx_not:
                        i = (i + 1)
                    while True:
                        i2 = i
                        i = (i + 1)
                        c2 = pattern.b[i2]
                        if (c2 == 93):
                            if (range != 0):
                                return None
                            break
                        elif (c2 == 45):
                            if (range != 0):
                                return None
                            last = (None if ((len(acc) == 0)) else acc.pop())
                            if (last is None):
                                acc.append(_hx_AnonObject({'min': c2, 'max': c2}))
                            else:
                                if (last.min != last.max):
                                    return None
                                range = last.min
                        else:
                            if (c2 == 92):
                                i3 = i
                                i = (i + 1)
                                c2 = pattern.b[i3]
                            if (range == 0):
                                acc.append(_hx_AnonObject({'min': c2, 'max': c2}))
                            else:
                                acc.append(_hx_AnonObject({'min': range, 'max': c2}))
                                range = 0
                    g = []
                    _g = 0
                    while (_g < len(acc)):
                        k = (acc[_g] if _g >= 0 and _g < len(acc) else None)
                        _g = (_g + 1)
                        g = hxparse_LexEngine.cunion(g,[k])
                    if _hx_not:
                        g = hxparse_LexEngine.cdiff(hxparse_LexEngine.ALL_CHARS,g)
                    r = hxparse_LexEngine.next(r,hxparse__LexEngine_Pattern.Match(g))
                else:
                    r = hxparse_LexEngine.next(r,hxparse__LexEngine_Pattern.Match([_hx_AnonObject({'min': c, 'max': c})]))
            elif (c1 == 92):
                i4 = i
                i = (i + 1)
                c = pattern.b[i4]
                if (c == -1):
                    c = 92
                elif ((c >= 48) and ((c <= 57))):
                    v = (c - 48)
                    while True:
                        cNext = pattern.b[i]
                        if ((cNext >= 48) and ((cNext <= 57))):
                            v = ((v * 10) + ((cNext - 48)))
                            i = (i + 1)
                        else:
                            break
                    c = v
                r = hxparse_LexEngine.next(r,hxparse__LexEngine_Pattern.Match([_hx_AnonObject({'min': c, 'max': c})]))
            elif (c1 == 124):
                if (r != hxparse__LexEngine_Pattern.Empty):
                    r21 = hxparse_LexEngine.parseInner(pattern,i)
                    return _hx_AnonObject({'pattern': hxparse__LexEngine_Pattern.Choice(r,r21.pattern), 'pos': r21.pos})
                else:
                    r = hxparse_LexEngine.next(r,hxparse__LexEngine_Pattern.Match([_hx_AnonObject({'min': c, 'max': c})]))
            else:
                r = hxparse_LexEngine.next(r,hxparse__LexEngine_Pattern.Match([_hx_AnonObject({'min': c, 'max': c})]))
        if (pDepth != 0):
            raise _HxException((("Found unclosed parenthesis while parsing \"" + Std.string(pattern)) + "\""))
        return _hx_AnonObject({'pattern': r, 'pos': i})


class hxparse__LexEngine_Pattern(Enum):
    __slots__ = ()
    _hx_class_name = "hxparse._LexEngine.Pattern"

    @staticmethod
    def Match(c):
        return hxparse__LexEngine_Pattern("Match", 1, [c])

    @staticmethod
    def Star(p):
        return hxparse__LexEngine_Pattern("Star", 2, [p])

    @staticmethod
    def Plus(p):
        return hxparse__LexEngine_Pattern("Plus", 3, [p])

    @staticmethod
    def Next(p1,p2):
        return hxparse__LexEngine_Pattern("Next", 4, [p1,p2])

    @staticmethod
    def Choice(p1,p2):
        return hxparse__LexEngine_Pattern("Choice", 5, [p1,p2])

    @staticmethod
    def Group(p):
        return hxparse__LexEngine_Pattern("Group", 6, [p])
hxparse__LexEngine_Pattern.Empty = hxparse__LexEngine_Pattern("Empty", 0, list())


class hxparse__LexEngine_Node:
    _hx_class_name = "hxparse._LexEngine.Node"
    __slots__ = ("id", "pid", "trans", "epsilon")
    _hx_fields = ["id", "pid", "trans", "epsilon"]

    def __init__(self,id,pid):
        self.id = id
        self.pid = pid
        self.trans = []
        self.epsilon = []



class hxparse__LexEngine_Transition:
    _hx_class_name = "hxparse._LexEngine.Transition"
    __slots__ = ("chars",)
    _hx_fields = ["chars"]
    _hx_methods = ["toString"]

    def __init__(self,chars):
        self.chars = chars

    def toString(self):
        return Std.string(self.chars)



class hxparse_Lexer:
    _hx_class_name = "hxparse.Lexer"
    __slots__ = ("current", "input", "source", "pos")
    _hx_fields = ["current", "input", "source", "pos"]
    _hx_methods = ["curPos", "token"]
    _hx_statics = ["buildRuleset"]

    def __init__(self,input,sourceName = "<null>"):
        if (sourceName is None):
            sourceName = "<null>"
        self.current = ""
        self.input = input
        self.source = sourceName
        self.pos = 0

    def curPos(self):
        return hxparse_Position(self.source,(self.pos - len(self.current)),self.pos)

    def token(self,ruleset):
        if (self.pos == self.input.length):
            if (ruleset.eofFunction is not None):
                return ruleset.eofFunction(self)
            else:
                raise _HxException(haxe_io_Eof())
        state = ruleset.state
        lastMatch = None
        lastMatchPos = self.pos
        start = self.pos
        while True:
            if (state.final > -1):
                lastMatch = state
                lastMatchPos = self.pos
            if (self.pos == self.input.length):
                break
            i = self.input.b[self.pos]
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 + 1)
            _hx_local_0.pos
            state = state.trans[i]
            if (state is None):
                break
        self.pos = lastMatchPos
        self.current = self.input.getString(start,(self.pos - start))
        if ((lastMatch is None) or ((lastMatch.final == -1))):
            code = self.input.b[self.pos]
            raise _HxException(hxparse_UnexpectedChar("".join(map(chr,[code])),hxparse_Position(self.source,(self.pos - len(self.current)),self.pos)))
        return python_internal_ArrayImpl._get(ruleset.functions, lastMatch.final)(self)

    @staticmethod
    def buildRuleset(rules,name = ""):
        if (name is None):
            name = ""
        cases = []
        functions = []
        eofFunction = None
        _g = 0
        while (_g < len(rules)):
            rule = (rules[_g] if _g >= 0 and _g < len(rules) else None)
            _g = (_g + 1)
            if (rule.rule == ""):
                eofFunction = rule.func
            else:
                x = hxparse_LexEngine.parse(rule.rule)
                cases.append(x)
                x1 = rule.func
                functions.append(x1)
        return hxparse_Ruleset(hxparse_LexEngine(cases).firstState(),functions,eofFunction,name)



class hxparse_LexerTokenSource:
    _hx_class_name = "hxparse.LexerTokenSource"
    __slots__ = ("lexer", "ruleset")
    _hx_fields = ["lexer", "ruleset"]
    _hx_methods = ["token", "curPos"]

    def __init__(self,lexer,ruleset):
        self.lexer = lexer
        self.ruleset = ruleset

    def token(self):
        return self.lexer.token(self.ruleset)

    def curPos(self):
        _this = self.lexer
        return hxparse_Position(_this.source,(_this.pos - len(_this.current)),_this.pos)



class hxparse_ParserError:
    _hx_class_name = "hxparse.ParserError"
    __slots__ = ("pos",)
    _hx_fields = ["pos"]
    _hx_methods = ["toString"]

    def __init__(self,pos):
        self.pos = pos

    def toString(self):
        return "Parser error"



class hxparse_NoMatch(hxparse_ParserError):
    _hx_class_name = "hxparse.NoMatch"
    __slots__ = ("token",)
    _hx_fields = ["token"]
    _hx_methods = ["toString"]
    _hx_statics = []
    _hx_super = hxparse_ParserError


    def __init__(self,pos,token):
        self.token = None
        super().__init__(pos)
        self.token = token

    def toString(self):
        return ("No match: " + Std.string(self.token))



class hxparse_Parser:
    _hx_class_name = "hxparse.Parser"
    __slots__ = ("last", "stream", "token")
    _hx_fields = ["last", "stream", "token"]
    _hx_methods = ["peek", "junk", "curPos", "parseSeparated", "parseOptional", "parseRepeat", "parseExpect", "noMatch", "unexpected"]

    def __init__(self,stream):
        self.token = None
        self.last = None
        self.stream = stream

    def peek(self,n):
        if (self.token is None):
            self.token = haxe_ds_GenericCell(self.stream.token(),None)
            n = (n - 1)
        tok = self.token
        while (n > 0):
            if (tok.next is None):
                tok.next = haxe_ds_GenericCell(self.stream.token(),None)
            tok = tok.next
            n = (n - 1)
        return tok.elt

    def junk(self):
        self.last = self.token.elt
        self.token = self.token.next

    def curPos(self):
        return self.stream.curPos()

    def parseSeparated(self,separatorFunc,f):
        acc = []
        while True:
            try:
                x = f()
                acc.append(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, hxparse_NoMatch):
                    e = _hx_e1
                    break
                else:
                    raise _hx_e
            if separatorFunc(self.peek(0)):
                self.last = self.token.elt
                self.token = self.token.next
            else:
                break
        return acc

    def parseOptional(self,f):
        try:
            return f()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, hxparse_NoMatch):
                e = _hx_e1
                return None
            else:
                raise _hx_e

    def parseRepeat(self,f):
        acc = []
        while True:
            try:
                x = f()
                acc.append(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, hxparse_NoMatch):
                    e = _hx_e1
                    return acc
                else:
                    raise _hx_e

    def parseExpect(self,f):
        try:
            return f()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, hxparse_NoMatch):
                _ = _hx_e1
                raise _HxException(hxparse_Unexpected(self.peek(0),self.stream.curPos()))
            else:
                raise _hx_e

    def noMatch(self):
        return hxparse_NoMatch(self.stream.curPos(),self.peek(0))

    def unexpected(self):
        raise _HxException(hxparse_Unexpected(self.peek(0),self.stream.curPos()))



class hxparse_Parser_hxparse_LexerTokenSource_thttil_TokenDef_thttil_TokenDef:
    _hx_class_name = "hxparse.Parser_hxparse_LexerTokenSource_thttil_TokenDef_thttil_TokenDef"
    __slots__ = ("last", "stream", "token")
    _hx_fields = ["last", "stream", "token"]
    _hx_methods = ["peek", "junk", "curPos", "parseSeparated", "parseOptional", "parseRepeat", "parseExpect", "noMatch", "unexpected"]

    def __init__(self,stream):
        self.token = None
        self.last = None
        self.stream = stream

    def peek(self,n):
        if (self.token is None):
            self.token = haxe_ds_GenericCell(self.stream.token(),None)
            n = (n - 1)
        tok = self.token
        while (n > 0):
            if (tok.next is None):
                tok.next = haxe_ds_GenericCell(self.stream.token(),None)
            tok = tok.next
            n = (n - 1)
        return tok.elt

    def junk(self):
        self.last = self.token.elt
        self.token = self.token.next

    def curPos(self):
        return self.stream.curPos()

    def parseSeparated(self,separatorFunc,f):
        acc = []
        while True:
            try:
                x = f()
                acc.append(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, hxparse_NoMatch):
                    e = _hx_e1
                    break
                else:
                    raise _hx_e
            if separatorFunc(self.peek(0)):
                self.last = self.token.elt
                self.token = self.token.next
            else:
                break
        return acc

    def parseOptional(self,f):
        try:
            return f()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, hxparse_NoMatch):
                e = _hx_e1
                return None
            else:
                raise _hx_e

    def parseRepeat(self,f):
        acc = []
        while True:
            try:
                x = f()
                acc.append(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, hxparse_NoMatch):
                    e = _hx_e1
                    return acc
                else:
                    raise _hx_e

    def parseExpect(self,f):
        try:
            return f()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, hxparse_NoMatch):
                _ = _hx_e1
                raise _HxException(hxparse_Unexpected(self.peek(0),self.stream.curPos()))
            else:
                raise _hx_e

    def noMatch(self):
        return hxparse_NoMatch(self.stream.curPos(),self.peek(0))

    def unexpected(self):
        raise _HxException(hxparse_Unexpected(self.peek(0),self.stream.curPos()))



class hxparse_Position:
    _hx_class_name = "hxparse.Position"
    __slots__ = ("psource", "pmin", "pmax")
    _hx_fields = ["psource", "pmin", "pmax"]
    _hx_methods = ["toString", "getLinePosition", "format"]
    _hx_statics = ["union"]

    def __init__(self,source,_hx_min,_hx_max):
        self.psource = source
        self.pmin = _hx_min
        self.pmax = _hx_max

    def toString(self):
        return ((((("" + HxOverrides.stringOrNull(self.psource)) + ":characters ") + Std.string(self.pmin)) + "-") + Std.string(self.pmax))

    def getLinePosition(self,input):
        lineMin = 1
        lineMax = 1
        posMin = 0
        posMax = 0
        cur = 0
        while (cur < self.pmin):
            if (input.b[cur] == 10):
                lineMin = (lineMin + 1)
                posMin = (cur + 1)
            cur = (cur + 1)
        lineMax = lineMin
        posMax = posMin
        posMin = (cur - posMin)
        while (cur < self.pmax):
            if (input.b[cur] == 10):
                lineMax = (lineMax + 1)
                posMax = (cur + 1)
            cur = (cur + 1)
        posMax = (cur - posMax)
        return _hx_AnonObject({'lineMin': lineMin, 'lineMax': lineMax, 'posMin': posMin, 'posMax': posMax})

    def format(self,input):
        linePos = self.getLinePosition(input)
        if (linePos.lineMin != linePos.lineMax):
            return ((((("" + HxOverrides.stringOrNull(self.psource)) + ":lines ") + Std.string(linePos.lineMin)) + "-") + Std.string(linePos.lineMax))
        else:
            return ((((((("" + HxOverrides.stringOrNull(self.psource)) + ":") + Std.string(linePos.lineMin)) + ": characters ") + Std.string(linePos.posMin)) + "-") + Std.string(linePos.posMax))

    @staticmethod
    def union(p1,p2):
        return hxparse_Position(p1.psource,(p1.pmin if ((p1.pmin < p2.pmin)) else p2.pmin),(p1.pmax if ((p1.pmax > p2.pmax)) else p2.pmax))



class hxparse_RuleBuilder:
    _hx_class_name = "hxparse.RuleBuilder"
    __slots__ = ()


class hxparse_RuleBuilderImpl:
    _hx_class_name = "hxparse.RuleBuilderImpl"
    __slots__ = ()


class hxparse_Ruleset:
    _hx_class_name = "hxparse.Ruleset"
    __slots__ = ("state", "functions", "eofFunction", "name")
    _hx_fields = ["state", "functions", "eofFunction", "name"]

    def __init__(self,state,functions,eofFunction,name = ""):
        if (name is None):
            name = ""
        self.state = state
        self.functions = functions
        self.eofFunction = eofFunction
        self.name = name



class hxparse_State:
    _hx_class_name = "hxparse.State"
    __slots__ = ("trans", "final")
    _hx_fields = ["trans", "final"]

    def __init__(self):
        self.final = -1
        this1 = [None]*256
        self.trans = this1



class hxparse_Unexpected(hxparse_ParserError):
    _hx_class_name = "hxparse.Unexpected"
    __slots__ = ("token",)
    _hx_fields = ["token"]
    _hx_methods = ["toString"]
    _hx_statics = []
    _hx_super = hxparse_ParserError


    def __init__(self,token,pos):
        self.token = None
        super().__init__(pos)
        self.token = token

    def toString(self):
        return ("Unexpected " + Std.string(self.token))



class hxparse_UnexpectedChar(hxparse_ParserError):
    _hx_class_name = "hxparse.UnexpectedChar"
    __slots__ = ("char",)
    _hx_fields = ["char"]
    _hx_methods = ["toString"]
    _hx_statics = []
    _hx_super = hxparse_ParserError


    def __init__(self,char,pos):
        self.char = None
        super().__init__(pos)
        self.char = char

    def toString(self):
        return ("Unexpected " + HxOverrides.stringOrNull(self.char))



class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if isinstance(o,int):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g1 = 0
            _g = l
            while (_g1 < _g):
                i = _g1
                _g1 = (_g1 + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        if (python_lib_Inspect.isfunction(o) or python_lib_Inspect.ismethod(o)):
            return "<function>"
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g2 = []
                    _g11 = 0
                    while (_g11 < len(fields)):
                        f = (fields[_g11] if _g11 >= 0 and _g11 < len(fields) else None)
                        _g11 = (_g11 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g2.append(x)
                    fieldsStr = _g2
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o2 = o
                l1 = len(o2.params)
                hasParams = (l1 > 0)
                if hasParams:
                    paramsStr = ""
                    _g12 = 0
                    _g3 = l1
                    while (_g12 < _g3):
                        i1 = _g12
                        _g12 = (_g12 + 1)
                        prefix1 = ""
                        if (i1 > 0):
                            prefix1 = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix1 is None else prefix1) + HxOverrides.stringOrNull(python_Boot.toString1((o2.params[i1] if i1 >= 0 and i1 < len(o2.params) else None),s))))))
                    return (((HxOverrides.stringOrNull(o2.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o2.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields1 = python_Boot.getInstanceFields(o)
                    _g4 = []
                    _g13 = 0
                    while (_g13 < len(fields1)):
                        f1 = (fields1[_g13] if _g13 >= 0 and _g13 < len(fields1) else None)
                        _g13 = (_g13 + 1)
                        x1 = ((("" + ("null" if f1 is None else f1)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f1),(("null" if s is None else s) + "\t"))))
                        _g4.append(x1)
                    fieldsStr1 = _g4
                    toStr1 = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr1]))) + " )")
                    return toStr1
                else:
                    fields2 = python_Boot.getClassFields(o)
                    _g5 = []
                    _g14 = 0
                    while (_g14 < len(fields2)):
                        f2 = (fields2[_g14] if _g14 >= 0 and _g14 < len(fields2) else None)
                        _g14 = (_g14 + 1)
                        x2 = ((("" + ("null" if f2 is None else f2)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f2),(("null" if s is None else s) + "\t"))))
                        _g5.append(x2)
                    fieldsStr2 = _g5
                    toStr2 = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr2]))) + " )")
                    return toStr2
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                pass
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d1 = o.__dict__
                keys1 = d1.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        field1 = field
        _hx_local_0 = len(field1)
        if (_hx_local_0 == 10):
            if (field1 == "charCodeAt"):
                if isinstance(o,str):
                    s1 = o
                    def _hx_local_1(a11):
                        return HxString.charCodeAt(s1,a11)
                    return _hx_local_1
        elif (_hx_local_0 == 11):
            if (field1 == "lastIndexOf"):
                if isinstance(o,str):
                    s3 = o
                    def _hx_local_2(a15):
                        return HxString.lastIndexOf(s3,a15)
                    return _hx_local_2
                elif isinstance(o,list):
                    a4 = o
                    def _hx_local_3(x4):
                        return python_internal_ArrayImpl.lastIndexOf(a4,x4)
                    return _hx_local_3
            elif (field1 == "toLowerCase"):
                if isinstance(o,str):
                    s7 = o
                    def _hx_local_4():
                        return HxString.toLowerCase(s7)
                    return _hx_local_4
            elif (field1 == "toUpperCase"):
                if isinstance(o,str):
                    s9 = o
                    def _hx_local_5():
                        return HxString.toUpperCase(s9)
                    return _hx_local_5
        elif (_hx_local_0 == 9):
            if (field1 == "substring"):
                if isinstance(o,str):
                    s6 = o
                    def _hx_local_6(a19):
                        return HxString.substring(s6,a19)
                    return _hx_local_6
        elif (_hx_local_0 == 4):
            if (field1 == "copy"):
                if isinstance(o,list):
                    def _hx_local_7():
                        return list(o)
                    return _hx_local_7
            elif (field1 == "join"):
                if isinstance(o,list):
                    def _hx_local_8(sep):
                        return sep.join([python_Boot.toString1(x1,'') for x1 in o])
                    return _hx_local_8
            elif (field1 == "push"):
                if isinstance(o,list):
                    x7 = o
                    def _hx_local_9(e):
                        return python_internal_ArrayImpl.push(x7,e)
                    return _hx_local_9
            elif (field1 == "sort"):
                if isinstance(o,list):
                    x11 = o
                    def _hx_local_10(f2):
                        python_internal_ArrayImpl.sort(x11,f2)
                    return _hx_local_10
        elif (_hx_local_0 == 5):
            if (field1 == "shift"):
                if isinstance(o,list):
                    x9 = o
                    def _hx_local_11():
                        return python_internal_ArrayImpl.shift(x9)
                    return _hx_local_11
            elif (field1 == "slice"):
                if isinstance(o,list):
                    x10 = o
                    def _hx_local_12(a16):
                        return python_internal_ArrayImpl.slice(x10,a16)
                    return _hx_local_12
            elif (field1 == "split"):
                if isinstance(o,str):
                    s4 = o
                    def _hx_local_13(d):
                        return HxString.split(s4,d)
                    return _hx_local_13
        elif (_hx_local_0 == 7):
            if (field1 == "indexOf"):
                if isinstance(o,str):
                    s2 = o
                    def _hx_local_14(a13):
                        return HxString.indexOf(s2,a13)
                    return _hx_local_14
                elif isinstance(o,list):
                    a = o
                    def _hx_local_15(x1):
                        return python_internal_ArrayImpl.indexOf(a,x1)
                    return _hx_local_15
            elif (field1 == "reverse"):
                if isinstance(o,list):
                    a5 = o
                    def _hx_local_16():
                        python_internal_ArrayImpl.reverse(a5)
                    return _hx_local_16
            elif (field1 == "unshift"):
                if isinstance(o,list):
                    x14 = o
                    def _hx_local_17(e2):
                        python_internal_ArrayImpl.unshift(x14,e2)
                    return _hx_local_17
        elif (_hx_local_0 == 3):
            if (field1 == "map"):
                if isinstance(o,list):
                    x5 = o
                    def _hx_local_18(f1):
                        return python_internal_ArrayImpl.map(x5,f1)
                    return _hx_local_18
            elif (field1 == "pop"):
                if isinstance(o,list):
                    x6 = o
                    def _hx_local_19():
                        return python_internal_ArrayImpl.pop(x6)
                    return _hx_local_19
        elif (_hx_local_0 == 8):
            if (field1 == "iterator"):
                if isinstance(o,list):
                    x3 = o
                    def _hx_local_20():
                        return python_internal_ArrayImpl.iterator(x3)
                    return _hx_local_20
            elif (field1 == "toString"):
                if isinstance(o,str):
                    s8 = o
                    def _hx_local_21():
                        return HxString.toString(s8)
                    return _hx_local_21
                elif isinstance(o,list):
                    x13 = o
                    def _hx_local_22():
                        return python_internal_ArrayImpl.toString(x13)
                    return _hx_local_22
        elif (_hx_local_0 == 6):
            if (field1 == "charAt"):
                if isinstance(o,str):
                    s = o
                    def _hx_local_23(a1):
                        return HxString.charAt(s,a1)
                    return _hx_local_23
            elif (field1 == "concat"):
                if isinstance(o,list):
                    a12 = o
                    def _hx_local_24(a2):
                        return python_internal_ArrayImpl.concat(a12,a2)
                    return _hx_local_24
            elif (field1 == "filter"):
                if isinstance(o,list):
                    x = o
                    def _hx_local_25(f):
                        return python_internal_ArrayImpl.filter(x,f)
                    return _hx_local_25
            elif (field1 == "insert"):
                if isinstance(o,list):
                    a3 = o
                    def _hx_local_26(a14,x2):
                        python_internal_ArrayImpl.insert(a3,a14,x2)
                    return _hx_local_26
            elif (field1 == "length"):
                if isinstance(o,str):
                    return len(o)
                elif isinstance(o,list):
                    return len(o)
            elif (field1 == "remove"):
                if isinstance(o,list):
                    x8 = o
                    def _hx_local_27(e1):
                        return python_internal_ArrayImpl.remove(x8,e1)
                    return _hx_local_27
            elif (field1 == "splice"):
                if isinstance(o,list):
                    x12 = o
                    def _hx_local_28(a17,a21):
                        return python_internal_ArrayImpl.splice(x12,a17,a21)
                    return _hx_local_28
            elif (field1 == "substr"):
                if isinstance(o,str):
                    s5 = o
                    def _hx_local_29(a18):
                        return HxString.substr(s5,a18)
                    return _hx_local_29
        else:
            pass
        field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field2):
            return getattr(o,field2)
        else:
            return None

    @staticmethod
    def getInstanceFields(c):
        f = (c._hx_fields if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, StopIteration):
                    s = _hx_e1
                    self.has = False
                    self.x = None
                else:
                    raise _hx_e
            self.checked = True
        return self.has



class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["concat", "iterator", "indexOf", "lastIndexOf", "toString", "pop", "push", "unshift", "remove", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g1 = l
        _g = _hx_len
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            if (a[i] == x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if (a[l] == x):
                return l
        return -1

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            return False

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v


class _HxException(Exception):
    _hx_class_name = "_HxException"
    __slots__ = ("val",)
    _hx_fields = ["val"]
    _hx_methods = []
    _hx_statics = []
    _hx_super = Exception


    def __init__(self,val):
        self.val = None
        message = str(val)
        super().__init__(message)
        self.val = val



class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["eq", "stringOrNull"]

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s


class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            return s[startIndex:(startIndex + _hx_len)]

class thttil_TokenDef(Enum):
    __slots__ = ()
    _hx_class_name = "thttil.TokenDef"

    @staticmethod
    def TPrintToken(content):
        return thttil_TokenDef("TPrintToken", 0, [content])

    @staticmethod
    def TKeyword(keyword):
        return thttil_TokenDef("TKeyword", 1, [keyword])

    @staticmethod
    def TComment(content):
        return thttil_TokenDef("TComment", 2, [content])

    @staticmethod
    def TConst(const):
        return thttil_TokenDef("TConst", 3, [const])
thttil_TokenDef.TDot = thttil_TokenDef("TDot", 4, list())
thttil_TokenDef.TEndToken = thttil_TokenDef("TEndToken", 5, list())
thttil_TokenDef.TBeginToken = thttil_TokenDef("TBeginToken", 6, list())
thttil_TokenDef.TBeginStream = thttil_TokenDef("TBeginStream", 7, list())
thttil_TokenDef.TBeginVariable = thttil_TokenDef("TBeginVariable", 8, list())
thttil_TokenDef.TEndUsingString = thttil_TokenDef("TEndUsingString", 9, list())
thttil_TokenDef.TBeginUsingString = thttil_TokenDef("TBeginUsingString", 10, list())
thttil_TokenDef.TStreamRedirection = thttil_TokenDef("TStreamRedirection", 11, list())
thttil_TokenDef.TArgumentSeparator = thttil_TokenDef("TArgumentSeparator", 12, list())
thttil_TokenDef.TEndInstructionBlock = thttil_TokenDef("TEndInstructionBlock", 13, list())
thttil_TokenDef.TBeginInstructionBlock = thttil_TokenDef("TBeginInstructionBlock", 14, list())
thttil_TokenDef.TEOF = thttil_TokenDef("TEOF", 15, list())

class thttil_Keyword(Enum):
    __slots__ = ()
    _hx_class_name = "thttil.Keyword"
thttil_Keyword.KwdAs = thttil_Keyword("KwdAs", 0, list())
thttil_Keyword.KwdUsing = thttil_Keyword("KwdUsing", 1, list())


class thttil_Lexer(hxparse_Lexer):
    _hx_class_name = "thttil.Lexer"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["temp_buffer", "identifier", "tokens", "string", "print", "generatedRulesets"]
    _hx_super = hxparse_Lexer


    def __init__(self,input,sourceName = None):
        super().__init__(input,sourceName)
    temp_buffer = None


class thttil_Parser(hxparse_Parser_hxparse_LexerTokenSource_thttil_TokenDef_thttil_TokenDef):
    _hx_class_name = "thttil.Parser"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["parseProgram", "parseToken", "parseTokenInstructionBlock", "parseTokenInstructionBlockContent", "parseTokenArguments", "parseTokenArgumentContent", "parseVariableSubScopes", "toString"]
    _hx_statics = []
    _hx_super = hxparse_Parser_hxparse_LexerTokenSource_thttil_TokenDef_thttil_TokenDef


    def __init__(self,input,source_name):
        lexer = thttil_Lexer(input,source_name)
        token_source = hxparse_LexerTokenSource(lexer,thttil_Lexer.tokens)
        super().__init__(token_source)

    def parseProgram(self):
        program = thttil_symbols_Program([])
        token = None
        while True:
            token = self.parseToken()
            if (token is not None):
                _this = program.instructions
                _this.append(token)
            if (not ((token is not None))):
                break
        return program

    def parseToken(self):
        _g = self.peek(0)
        _g1 = _g.index
        if (_g1 == 0):
            content = _g.params[0]
            self.last = self.token.elt
            self.token = self.token.next
            return thttil_symbols_Token("OUT",[thttil_symbols_PString(content)],None)
        elif (_g1 == 6):
            self.last = self.token.elt
            self.token = self.token.next
            _g2 = self.peek(0)
            if (_g2.index == 3):
                if (_g2.params[0].index == 3):
                    command_name = _g2.params[0].params[0]
                    self.last = self.token.elt
                    self.token = self.token.next
                    arguments = self.parseTokenArguments([])
                    block = self.parseTokenInstructionBlock()
                    return thttil_symbols_Token(command_name,arguments,block)
                else:
                    raise _HxException(hxparse_Unexpected(self.peek(0),self.stream.curPos()))
            else:
                raise _HxException(hxparse_Unexpected(self.peek(0),self.stream.curPos()))
        elif (_g1 == 7):
            self.last = self.token.elt
            self.token = self.token.next
            _g3 = self.peek(0)
            if (_g3.index == 3):
                if (_g3.params[0].index == 3):
                    istream = _g3.params[0].params[0]
                    self.last = self.token.elt
                    self.token = self.token.next
                    _g4 = self.peek(0)
                    if (_g4.index == 11):
                        self.last = self.token.elt
                        self.token = self.token.next
                        _g5 = self.peek(0)
                        if (_g5.index == 7):
                            self.last = self.token.elt
                            self.token = self.token.next
                            _g6 = self.peek(0)
                            if (_g6.index == 3):
                                if (_g6.params[0].index == 3):
                                    ostream = _g6.params[0].params[0]
                                    self.last = self.token.elt
                                    self.token = self.token.next
                                    return thttil_symbols_Token("REDIRECTION",[thttil_symbols_Stream(istream), thttil_symbols_Stream(ostream)],None)
                                else:
                                    raise _HxException(hxparse_Unexpected(self.peek(0),self.stream.curPos()))
                            else:
                                raise _HxException(hxparse_Unexpected(self.peek(0),self.stream.curPos()))
                        else:
                            raise _HxException(hxparse_Unexpected(self.peek(0),self.stream.curPos()))
                    else:
                        return thttil_symbols_Token("SELECT",[thttil_symbols_Stream(istream)],None)
                else:
                    raise _HxException(hxparse_Unexpected(self.peek(0),self.stream.curPos()))
            else:
                raise _HxException(hxparse_Unexpected(self.peek(0),self.stream.curPos()))
        elif (_g1 == 15):
            self.last = self.token.elt
            self.token = self.token.next
            return None
        else:
            raise _HxException(hxparse_NoMatch(self.stream.curPos(),self.peek(0)))

    def parseTokenInstructionBlock(self):
        if (self.peek(0) != thttil_TokenDef.TBeginInstructionBlock):
            return None
        self.last = self.token.elt
        self.token = self.token.next
        return self.parseTokenInstructionBlockContent([])

    def parseTokenInstructionBlockContent(self,accumulator):
        _g = self.peek(0)
        if (_g.index == 13):
            self.last = self.token.elt
            self.token = self.token.next
            return accumulator
        else:
            token = self.parseToken()
            accumulator.append(token)
            _g1 = self.peek(0)
            if (_g1.index == 13):
                self.last = self.token.elt
                self.token = self.token.next
                return accumulator
            else:
                return self.parseTokenInstructionBlockContent(accumulator)

    def parseTokenArguments(self,accumulator):
        _g = self.peek(0)
        if (_g.index == 5):
            self.last = self.token.elt
            self.token = self.token.next
            return accumulator
        else:
            arg = self.parseTokenArgumentContent()
            accumulator.append(arg)
            _g1 = self.peek(0)
            _g2 = _g1.index
            if (_g2 == 5):
                self.last = self.token.elt
                self.token = self.token.next
                return accumulator
            elif (_g2 == 12):
                self.last = self.token.elt
                self.token = self.token.next
                return self.parseTokenArguments(accumulator)
            else:
                raise _HxException(hxparse_NoMatch(self.stream.curPos(),self.peek(0)))

    def parseTokenArgumentContent(self):
        _g = self.peek(0)
        _g1 = _g.index
        if (_g1 == 3):
            if (_g.params[0].index == 2):
                content = _g.params[0].params[0]
                self.last = self.token.elt
                self.token = self.token.next
                return thttil_symbols_PString(content)
            else:
                token = self.parseToken()
                return token
        elif (_g1 == 7):
            self.last = self.token.elt
            self.token = self.token.next
            _g2 = self.peek(0)
            if (_g2.index == 3):
                if (_g2.params[0].index == 3):
                    identifier = _g2.params[0].params[0]
                    self.last = self.token.elt
                    self.token = self.token.next
                    return thttil_symbols_Stream(identifier)
                else:
                    raise _HxException(hxparse_Unexpected(self.peek(0),self.stream.curPos()))
            else:
                raise _HxException(hxparse_Unexpected(self.peek(0),self.stream.curPos()))
        elif (_g1 == 8):
            self.last = self.token.elt
            self.token = self.token.next
            _g3 = self.peek(0)
            if (_g3.index == 3):
                if (_g3.params[0].index == 3):
                    identifier1 = _g3.params[0].params[0]
                    self.last = self.token.elt
                    self.token = self.token.next
                    sub_scopes = self.parseVariableSubScopes([])
                    return thttil_symbols_Variable(identifier1,sub_scopes)
                else:
                    raise _HxException(hxparse_Unexpected(self.peek(0),self.stream.curPos()))
            else:
                raise _HxException(hxparse_Unexpected(self.peek(0),self.stream.curPos()))
        else:
            token1 = self.parseToken()
            return token1

    def parseVariableSubScopes(self,accumulator):
        _g = self.peek(0)
        if (_g.index == 4):
            self.last = self.token.elt
            self.token = self.token.next
            _g1 = self.peek(0)
            if (_g1.index == 3):
                if (_g1.params[0].index == 3):
                    identifier = _g1.params[0].params[0]
                    self.last = self.token.elt
                    self.token = self.token.next
                    accumulator.append(identifier)
                    return self.parseVariableSubScopes(accumulator)
                else:
                    raise _HxException(hxparse_Unexpected(self.peek(0),self.stream.curPos()))
            else:
                raise _HxException(hxparse_Unexpected(self.peek(0),self.stream.curPos()))
        else:
            return accumulator

    def toString(self):
        tree = ""
        while True:
            _g = self.stream.token()
            _g1 = _g.index
            if (_g1 == 0):
                content = _g.params[0]
                tree = (("null" if tree is None else tree) + HxOverrides.stringOrNull(((("TPrintToken (" + ("null" if content is None else content)) + ") "))))
            elif (_g1 == 1):
                keyword = _g.params[0]
                tree = (("null" if tree is None else tree) + ((("Keyword (" + Std.string(keyword)) + ") ")))
            elif (_g1 == 2):
                content1 = _g.params[0]
                tree = (("null" if tree is None else tree) + HxOverrides.stringOrNull(((("Comment (" + ("null" if content1 is None else content1)) + ") "))))
            elif (_g1 == 3):
                tmp = _g.params[0].index
                if (tmp == 2):
                    content2 = _g.params[0].params[0]
                    tree = (("null" if tree is None else tree) + HxOverrides.stringOrNull(((("String (" + ("null" if content2 is None else content2)) + ") "))))
                elif (tmp == 3):
                    name = _g.params[0].params[0]
                    tree = (("null" if tree is None else tree) + HxOverrides.stringOrNull(((("Identifier (" + ("null" if name is None else name)) + ") "))))
                else:
                    return (("null" if tree is None else tree) + "! UNEXPECTED !")
            elif (_g1 == 4):
                tree = (("null" if tree is None else tree) + "Dot ")
            elif (_g1 == 5):
                tree = (("null" if tree is None else tree) + "EndToken ")
            elif (_g1 == 6):
                tree = (("null" if tree is None else tree) + "BeginToken ")
            elif (_g1 == 7):
                tree = (("null" if tree is None else tree) + "BeginStream ")
            elif (_g1 == 8):
                tree = (("null" if tree is None else tree) + "BeginVariable ")
            elif (_g1 == 9):
                tree = (("null" if tree is None else tree) + "EndUsingString ")
            elif (_g1 == 10):
                tree = (("null" if tree is None else tree) + "BeginUsingString ")
            elif (_g1 == 11):
                tree = (("null" if tree is None else tree) + "StreamRedirection ")
            elif (_g1 == 12):
                tree = (("null" if tree is None else tree) + "ArgumentSeparator ")
            elif (_g1 == 13):
                tree = (("null" if tree is None else tree) + "EndInstructionBlock ")
            elif (_g1 == 14):
                tree = (("null" if tree is None else tree) + "BeginInstructionBlock ")
            elif (_g1 == 15):
                tree = (("null" if tree is None else tree) + "EOF")
                return tree
            else:
                pass



class thttil_Stream:
    _hx_class_name = "thttil.Stream"
    __slots__ = ("content", "name")
    _hx_fields = ["content", "name"]
    _hx_methods = ["append", "set", "get", "getName", "toString"]

    def __init__(self,name):
        self.name = name
        self.content = ""

    def append(self,content):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.content
        _hx_local_0.content = (("null" if _hx_local_1 is None else _hx_local_1) + ("null" if content is None else content))
        _hx_local_0.content

    def set(self,content):
        self.content = content

    def get(self):
        return self.content

    def getName(self):
        return self.name

    def toString(self):
        return (((("Stream (name = '" + HxOverrides.stringOrNull(self.name)) + "', content = '") + HxOverrides.stringOrNull(self.content)) + "')")



class thttil_StreamCollection:
    _hx_class_name = "thttil.StreamCollection"
    __slots__ = ("streams",)
    _hx_fields = ["streams"]
    _hx_methods = ["getNamedStream", "clearStreams"]

    def __init__(self):
        self.streams = haxe_ds_StringMap()

    def getNamedStream(self,name):
        if (not (name in self.streams.h)):
            this1 = self.streams
            value = thttil_Stream(name)
            this1.h[name] = value
        return self.streams.h.get(name,None)

    def clearStreams(self):
        self.streams = haxe_ds_StringMap()



class thttil_error_ParserError:
    _hx_class_name = "thttil.error.ParserError"
    __slots__ = ("message", "position")
    _hx_fields = ["message", "position"]

    def __init__(self,message,position):
        self.message = message
        self.position = position


class thttil_error_ParserErrorMessage(Enum):
    __slots__ = ()
    _hx_class_name = "thttil.error.ParserErrorMessage"

    @staticmethod
    def Unexpected(details):
        return thttil_error_ParserErrorMessage("Unexpected", 0, [details])

    @staticmethod
    def Custom(details):
        return thttil_error_ParserErrorMessage("Custom", 1, [details])


class thttil_symbols_Argument:
    _hx_class_name = "thttil.symbols.Argument"
    __slots__ = ()


class thttil_symbols_InstructionBlock:
    _hx_class_name = "thttil.symbols.InstructionBlock"
    __slots__ = ("instructions",)
    _hx_fields = ["instructions"]

    def __init__(self,instructions):
        self.instructions = instructions



class thttil_symbols_PString(thttil_symbols_Argument):
    _hx_class_name = "thttil.symbols.PString"
    __slots__ = ("content",)
    _hx_fields = ["content"]
    _hx_methods = []
    _hx_statics = []
    _hx_super = thttil_symbols_Argument


    def __init__(self,content):
        self.content = content



class thttil_symbols_Program(thttil_symbols_InstructionBlock):
    _hx_class_name = "thttil.symbols.Program"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_super = thttil_symbols_InstructionBlock


    def __init__(self,instructions):
        super().__init__(instructions)


class thttil_symbols_Variable(thttil_symbols_Argument):
    _hx_class_name = "thttil.symbols.Variable"
    __slots__ = ("name", "sub_scopes")
    _hx_fields = ["name", "sub_scopes"]
    _hx_methods = []
    _hx_statics = []
    _hx_super = thttil_symbols_Argument


    def __init__(self,name,sub_scopes):
        self.name = name
        self.sub_scopes = sub_scopes



class thttil_symbols_Stream(thttil_symbols_Variable):
    _hx_class_name = "thttil.symbols.Stream"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_super = thttil_symbols_Variable


    def __init__(self,name):
        super().__init__(name,[])


class thttil_symbols_Token(thttil_symbols_Argument):
    _hx_class_name = "thttil.symbols.Token"
    __slots__ = ("command_name", "arguments", "instruction_block")
    _hx_fields = ["command_name", "arguments", "instruction_block"]
    _hx_methods = []
    _hx_statics = []
    _hx_super = thttil_symbols_Argument


    def __init__(self,command_name,arguments,instruction_block = None):
        self.instruction_block = instruction_block
        self.command_name = command_name
        self.arguments = arguments


Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

hxparse_LexEngine.MAX_CODE = 255
hxparse_LexEngine.EMPTY = []
hxparse_LexEngine.ALL_CHARS = [_hx_AnonObject({'min': 0, 'max': 255})]
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
thttil_Lexer.identifier = "_*[a-zA-Z][a-zA-Z0-9_]*|_+[0-9][_a-zA-Z0-9]*"
def _hx_init_thttil_Lexer_tokens():
    def _hx_local_0(lexer):
        print(str(hxparse_Position(lexer.source,(lexer.pos - len(lexer.current)),lexer.pos)))
        thttil_Lexer.temp_buffer = StringBuf()
        lexer.token(thttil_Lexer.string)
        return thttil_TokenDef.TConst(haxe_macro_Constant.CString(thttil_Lexer.temp_buffer.b.getvalue()))
    def _hx_local_1(lexer1):
        thttil_Lexer.temp_buffer = StringBuf()
        lexer1.token(thttil_Lexer.print)
        return thttil_TokenDef.TPrintToken(thttil_Lexer.temp_buffer.b.getvalue())
    def _hx_local_2(lexer2):
        return lexer2.token(thttil_Lexer.tokens)
    def _hx_local_3(lexer3):
        return lexer3.token(thttil_Lexer.tokens)
    def _hx_local_4(lexer4):
        return thttil_TokenDef.TKeyword(thttil_Keyword.KwdAs)
    def _hx_local_5(lexer5):
        return thttil_TokenDef.TKeyword(thttil_Keyword.KwdUsing)
    def _hx_local_6(lexer6):
        return thttil_TokenDef.TDot
    def _hx_local_7(lexer7):
        return thttil_TokenDef.TEndToken
    def _hx_local_8(lexer8):
        return thttil_TokenDef.TBeginToken
    def _hx_local_9(lexer9):
        return thttil_TokenDef.TBeginStream
    def _hx_local_10(lexer10):
        return thttil_TokenDef.TBeginVariable
    def _hx_local_11(lexer11):
        return thttil_TokenDef.TEndUsingString
    def _hx_local_12(lexer12):
        return thttil_TokenDef.TBeginUsingString
    def _hx_local_13(lexer13):
        return thttil_TokenDef.TStreamRedirection
    def _hx_local_14(lexer14):
        return thttil_TokenDef.TArgumentSeparator
    def _hx_local_15(lexer15):
        return thttil_TokenDef.TEndInstructionBlock
    def _hx_local_16(lexer16):
        return thttil_TokenDef.TBeginInstructionBlock
    def _hx_local_17(lexer17):
        return thttil_TokenDef.TConst(haxe_macro_Constant.CIdent(lexer17.current))
    def _hx_local_18(lexer18):
        return thttil_TokenDef.TEOF
    return hxparse_Lexer.buildRuleset([_hx_AnonObject({'rule': "\"", 'func': _hx_local_0}), _hx_AnonObject({'rule': "%", 'func': _hx_local_1}), _hx_AnonObject({'rule': "[\r\n\t ]+", 'func': _hx_local_2}), _hx_AnonObject({'rule': "#[^\n\r]*", 'func': _hx_local_3}), _hx_AnonObject({'rule': "as", 'func': _hx_local_4}), _hx_AnonObject({'rule': "using", 'func': _hx_local_5}), _hx_AnonObject({'rule': "\\.", 'func': _hx_local_6}), _hx_AnonObject({'rule': "\\)", 'func': _hx_local_7}), _hx_AnonObject({'rule': "\\$\\(", 'func': _hx_local_8}), _hx_AnonObject({'rule': "@", 'func': _hx_local_9}), _hx_AnonObject({'rule': "\\$", 'func': _hx_local_10}), _hx_AnonObject({'rule': ">", 'func': _hx_local_11}), _hx_AnonObject({'rule': "<", 'func': _hx_local_12}), _hx_AnonObject({'rule': "->", 'func': _hx_local_13}), _hx_AnonObject({'rule': ",", 'func': _hx_local_14}), _hx_AnonObject({'rule': "}", 'func': _hx_local_15}), _hx_AnonObject({'rule': "{", 'func': _hx_local_16}), _hx_AnonObject({'rule': "_*[a-zA-Z][a-zA-Z0-9_]*|_+[0-9][_a-zA-Z0-9]*", 'func': _hx_local_17}), _hx_AnonObject({'rule': "", 'func': _hx_local_18})],"tokens")
thttil_Lexer.tokens = _hx_init_thttil_Lexer_tokens()
def _hx_init_thttil_Lexer_string():
    def _hx_local_0(lexer):
        _this = thttil_Lexer.temp_buffer
        s = "".join(map(chr,[9]))
        _this.b.write(s)
        return lexer.token(thttil_Lexer.string)
    def _hx_local_1(lexer1):
        _this1 = thttil_Lexer.temp_buffer
        s1 = "".join(map(chr,[10]))
        _this1.b.write(s1)
        return lexer1.token(thttil_Lexer.string)
    def _hx_local_2(lexer2):
        _this2 = thttil_Lexer.temp_buffer
        s2 = "".join(map(chr,[13]))
        _this2.b.write(s2)
        return lexer2.token(thttil_Lexer.string)
    def _hx_local_3(lexer3):
        _this3 = thttil_Lexer.temp_buffer
        s3 = "".join(map(chr,[7]))
        _this3.b.write(s3)
        return lexer3.token(thttil_Lexer.string)
    def _hx_local_4(lexer4):
        _this4 = thttil_Lexer.temp_buffer
        s4 = "".join(map(chr,[8]))
        _this4.b.write(s4)
        return lexer4.token(thttil_Lexer.string)
    def _hx_local_5(lexer5):
        _this5 = thttil_Lexer.temp_buffer
        s5 = "".join(map(chr,[12]))
        _this5.b.write(s5)
        return lexer5.token(thttil_Lexer.string)
    def _hx_local_6(lexer6):
        _this6 = thttil_Lexer.temp_buffer
        s6 = "".join(map(chr,[11]))
        _this6.b.write(s6)
        return lexer6.token(thttil_Lexer.string)
    def _hx_local_7(lexer7):
        _this7 = thttil_Lexer.temp_buffer
        s7 = "".join(map(chr,[34]))
        _this7.b.write(s7)
        return lexer7.token(thttil_Lexer.string)
    def _hx_local_8(lexer8):
        return hxparse_Position(lexer8.source,(lexer8.pos - len(lexer8.current)),lexer8.pos).pmax
    def _hx_local_9(lexer9):
        _this8 = thttil_Lexer.temp_buffer
        s8 = Std.string(lexer9.current)
        _this8.b.write(s8)
        return lexer9.token(thttil_Lexer.string)
    return hxparse_Lexer.buildRuleset([_hx_AnonObject({'rule': "\\\\t", 'func': _hx_local_0}), _hx_AnonObject({'rule': "\\\\n", 'func': _hx_local_1}), _hx_AnonObject({'rule': "\\\\r", 'func': _hx_local_2}), _hx_AnonObject({'rule': "\\\\a", 'func': _hx_local_3}), _hx_AnonObject({'rule': "\\\\b", 'func': _hx_local_4}), _hx_AnonObject({'rule': "\\\\f", 'func': _hx_local_5}), _hx_AnonObject({'rule': "\\\\v", 'func': _hx_local_6}), _hx_AnonObject({'rule': "\\\\\"", 'func': _hx_local_7}), _hx_AnonObject({'rule': "\"", 'func': _hx_local_8}), _hx_AnonObject({'rule': "[^\"]", 'func': _hx_local_9})],"string")
thttil_Lexer.string = _hx_init_thttil_Lexer_string()
def _hx_init_thttil_Lexer_print():
    def _hx_local_0(lexer):
        _this = thttil_Lexer.temp_buffer
        s = "".join(map(chr,[9]))
        _this.b.write(s)
        return lexer.token(thttil_Lexer.print)
    def _hx_local_1(lexer1):
        _this1 = thttil_Lexer.temp_buffer
        s1 = "".join(map(chr,[10]))
        _this1.b.write(s1)
        return lexer1.token(thttil_Lexer.print)
    def _hx_local_2(lexer2):
        _this2 = thttil_Lexer.temp_buffer
        s2 = "".join(map(chr,[13]))
        _this2.b.write(s2)
        return lexer2.token(thttil_Lexer.print)
    def _hx_local_3(lexer3):
        _this3 = thttil_Lexer.temp_buffer
        s3 = "".join(map(chr,[7]))
        _this3.b.write(s3)
        return lexer3.token(thttil_Lexer.print)
    def _hx_local_4(lexer4):
        _this4 = thttil_Lexer.temp_buffer
        s4 = "".join(map(chr,[8]))
        _this4.b.write(s4)
        return lexer4.token(thttil_Lexer.print)
    def _hx_local_5(lexer5):
        _this5 = thttil_Lexer.temp_buffer
        s5 = "".join(map(chr,[12]))
        _this5.b.write(s5)
        return lexer5.token(thttil_Lexer.print)
    def _hx_local_6(lexer6):
        _this6 = thttil_Lexer.temp_buffer
        s6 = "".join(map(chr,[11]))
        _this6.b.write(s6)
        return lexer6.token(thttil_Lexer.print)
    def _hx_local_7(lexer7):
        _this7 = thttil_Lexer.temp_buffer
        s7 = "".join(map(chr,[37]))
        _this7.b.write(s7)
        return lexer7.token(thttil_Lexer.print)
    def _hx_local_8(lexer8):
        return hxparse_Position(lexer8.source,(lexer8.pos - len(lexer8.current)),lexer8.pos).pmax
    def _hx_local_9(lexer9):
        _this8 = thttil_Lexer.temp_buffer
        s8 = Std.string(lexer9.current)
        _this8.b.write(s8)
        return lexer9.token(thttil_Lexer.print)
    return hxparse_Lexer.buildRuleset([_hx_AnonObject({'rule': "\\\\t", 'func': _hx_local_0}), _hx_AnonObject({'rule': "\\\\n", 'func': _hx_local_1}), _hx_AnonObject({'rule': "\\\\r", 'func': _hx_local_2}), _hx_AnonObject({'rule': "\\\\a", 'func': _hx_local_3}), _hx_AnonObject({'rule': "\\\\b", 'func': _hx_local_4}), _hx_AnonObject({'rule': "\\\\f", 'func': _hx_local_5}), _hx_AnonObject({'rule': "\\\\v", 'func': _hx_local_6}), _hx_AnonObject({'rule': "\\\\%", 'func': _hx_local_7}), _hx_AnonObject({'rule': "\\%", 'func': _hx_local_8}), _hx_AnonObject({'rule': "[^%]", 'func': _hx_local_9})],"print")
thttil_Lexer.print = _hx_init_thttil_Lexer_print()
thttil_Lexer.generatedRulesets = [thttil_Lexer.tokens, thttil_Lexer.string, thttil_Lexer.print]